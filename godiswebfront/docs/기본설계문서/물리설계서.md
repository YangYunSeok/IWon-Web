# 관리자 코인 관리 시스템 물리 설계서 (Admin Web)
(2026-01-14 기준, v0.1)

> 본 물리 설계서는 **개념/논리 설계서**와 **DB 테이블 명세**, **API·DTO 명세**, **참조 물리설계서(SoT=SC Service 패턴)**를 기반으로,  
> 실제 구현(배포/런타임/DB/연동/운영) 수준의 결정을 문서화한다.  
> - SoT(단일 진실의 원천): Smart Contract Service(SC Service)  
> - Admin Web은 “승인·통제·조회·결산”을 담당

---

## 0. 물리 설계의 전제

- 코인 가치 이동(발행/소각/전송)의 **최종 실행/확정(원장/Tx)**은 **SC Service**가 수행한다. (SoT)  
- Admin API는 **요청/승인 워크플로우**, **명령 오케스트레이션**, **조회 API 제공**이 주 역할이며, 조회는 **Admin DB + (선택) Projection DB** 기반이다.  
- UI는 **ApprovalStatus(결정 상태)**와 **AdminTransaction.status(실행 상태)**를 분리 표기한다. (pending UX)  
- 금액/잔액은 정수형(`bigint`, 단위: IWC), 시간은 `timestamptz`, 가변 필드는 `jsonb`를 기본으로 한다.

근거: 참조 물리설계서의 SoT/Projection 패턴, Admin DB 테이블 전제, 논리 설계서의 승인 확정 트랜잭션 처리 순서.

---

## 1. 배포/런타임 아키텍처(물리)

### 1.1 구성 요소

- **Admin Web(UI)**: React(Admin Console), 정적 리소스 배포
- **Admin API(Backend)**: Spring Boot(권장) 또는 Node.js
  - 인증/권한(RBAC), 승인 워크플로우, 조회 API
- **SC Service(SoT)**: 별도 서비스(블록체인 노드/지갑/키관리 포함)
- **DB**
  - **Admin DB(PostgreSQL)**: 승인/실행/감사/지갑/월별지급(관리 데이터)
  - **(선택) Projection DB(PostgreSQL/ClickHouse 등)**: 온체인 이벤트 기반 조회 최적화(거래/잔액/집계)
- **(선택) Message Broker(Kafka/RabbitMQ)**: SC 이벤트 전달/적재 안정성(outbox 패턴 권장)

### 1.2 물리 배포(권장)

- Admin Web: CDN/정적 호스팅 (Nginx + S3/CloudFront 등)
- Admin API: 컨테이너 배포(K8s) 또는 VM
- DB: Managed PostgreSQL(Primary + Read Replica 선택)
- Broker: Managed Kafka/RabbitMQ 선택

---

## 2. 인터페이스(물리) — 서비스 간 연동

### 2.1 Admin API → SC Service (명령 호출)

- 프로토콜: HTTPS
- 인증: **mTLS(권장)** 또는 서버-서버 토큰(JWT/API Key)
- 공통 헤더/필드(권장)
  - `X-Request-Id`: 멱등키(재시도/중복 방지)
  - `X-Correlation-Id`: 추적(로그/트레이싱)
  - `Authorization`: 서버 토큰
- 재시도 정책(권장)
  - 네트워크 타임아웃/5xx 시 동일 `X-Request-Id`로 재시도
  - SC Service는 동일 키에 대해 동일 결과 반환(멱등)

### 2.2 SC Service → (선택) Projection 적재

- 방법 A(권장): 이벤트(브로커) 기반 적재  
  `SC Service Outbox → Broker → Consumer(ETL) → Projection DB`
- 방법 B(차선): SC Service가 Projection DB에 직접 적재(결합도↑)

> Admin Web 특성상 “승인 워크플로우(관리 데이터)”는 Admin DB가 SoT이며,  
> “온체인 실행 결과/원장성 데이터”는 SC Service(또는 Projection)가 SoT라는 이원화가 핵심이다.

---

## 3. 보안(물리)

### 3.1 인증/인가

- Admin API: Bearer Token 기반(역할: operator/approver/viewer)
- RBAC: `ROLE_ADMIN_OPERATOR / ROLE_ADMIN_APPROVER / ROLE_ADMIN_VIEWER`
- 민감 기능(승인 confirm, 결산 다운로드 등)은 Approver 권장

### 3.2 데이터 보호

- 개인정보(이메일/전화 등)는 컬럼 레벨 마스킹/암호화 정책 적용 가능
- 감사 로그(audit_logs)는 변경/삭제 불가를 원칙(append-only)

### 3.3 키/지갑 관리(참조 패턴 준용)

- SC Service의 체인 키는 KMS/HSM 위임(가능 시)  
- Admin API는 절대 개인키를 보관/취급하지 않음(필요 시 SC Service 전용)

---

## 4. 물리 데이터 모델 (PostgreSQL DDL 수준)

> 아래 DDL은 `web-admin-db-tables.md`의 스키마를 **실제 DDL 형태로 정리**한 것이며,  
> DBMS/운영 정책에 맞춰 타입·인덱스를 미세 조정한다.

### 4.1 공통(확장) — uuid 생성/시간

```sql
-- PostgreSQL extensions
CREATE EXTENSION IF NOT EXISTS pgcrypto; -- gen_random_uuid()

-- 권장: 모든 시간은 timestamptz, 애플리케이션은 ISO-8601로 입출력
```

### 4.2 RBAC / 감사

```sql
CREATE TABLE IF NOT EXISTS admin_roles (
  id           uuid PRIMARY KEY,
  name         varchar(50) NOT NULL UNIQUE,
  description  text NULL
);

CREATE TABLE IF NOT EXISTS admin_users (
  id            uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  username      varchar(150) NOT NULL UNIQUE,
  display_name  varchar(200) NOT NULL,
  email         varchar(320) NULL,
  password_hash varchar(255) NOT NULL,
  role_id       uuid NOT NULL REFERENCES admin_roles(id),
  status        varchar(20) NOT NULL DEFAULT 'active', -- active/inactive
  created_at    timestamptz NOT NULL DEFAULT now(),
  last_login    timestamptz NULL
);

CREATE INDEX IF NOT EXISTS idx_admin_users_role_id ON admin_users(role_id);

CREATE TABLE IF NOT EXISTS audit_logs (
  id            uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  actor_id      uuid NULL REFERENCES admin_users(id),
  action        varchar(100) NOT NULL,
  resource_type varchar(100) NULL,
  resource_id   varchar(255) NULL,
  details       jsonb NULL,
  created_at    timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_created ON audit_logs(actor_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created ON audit_logs(created_at DESC);
```

### 4.3 임직원/지갑

```sql
CREATE TABLE IF NOT EXISTS employees (
  employee_id   varchar(50) PRIMARY KEY,
  name          varchar(200) NOT NULL,
  department    varchar(200) NULL,
  position      varchar(200) NULL,
  email         varchar(320) NULL,
  phone         varchar(50) NULL,
  hire_date     date NULL,
  wallet_status varchar(20) NOT NULL DEFAULT 'uncreated', -- uncreated/active/frozen
  created_at    timestamptz NOT NULL DEFAULT now(),
  updated_at    timestamptz NULL
);

CREATE INDEX IF NOT EXISTS idx_employees_department ON employees(department);
CREATE INDEX IF NOT EXISTS idx_employees_name ON employees(name);

CREATE TABLE IF NOT EXISTS coin_types (
  coin_type varchar(50) PRIMARY KEY, -- welfare/payment
  name      varchar(100) NOT NULL,
  decimals  integer NOT NULL DEFAULT 0,
  metadata  jsonb NULL
);

CREATE TABLE IF NOT EXISTS wallets (
  id           uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  employee_id  varchar(50) NOT NULL REFERENCES employees(employee_id),
  address      varchar(200) NULL UNIQUE,
  status       varchar(20) NOT NULL DEFAULT 'uncreated',
  balance      bigint NOT NULL DEFAULT 0,
  coin_type    varchar(50) NOT NULL REFERENCES coin_types(coin_type),
  created_at   timestamptz NOT NULL DEFAULT now(),
  activated_at timestamptz NULL,
  frozen_at    timestamptz NULL,
  last_sync_at timestamptz NULL
);

CREATE INDEX IF NOT EXISTS idx_wallets_employee_id ON wallets(employee_id);
CREATE INDEX IF NOT EXISTS idx_wallets_coin_type ON wallets(coin_type);
```

### 4.4 승인/실행/원장(관리 관점)

```sql
CREATE TABLE IF NOT EXISTS approvals (
  id             uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  type           varchar(30) NOT NULL,   -- settlement/naverpayConversion/mint/burn
  requester_type varchar(30) NOT NULL,   -- merchant/system/admin
  requester_id   uuid NULL REFERENCES admin_users(id),
  requester_name varchar(200) NULL,
  subject_name   varchar(200) NULL,
  request_payload jsonb NOT NULL,
  amount         bigint NULL,
  coin_type      varchar(50) NULL REFERENCES coin_types(coin_type),
  status         varchar(30) NOT NULL DEFAULT 'pending', -- pending/approved/rejected
  approver_id    uuid NULL REFERENCES admin_users(id),
  requested_at   timestamptz NOT NULL DEFAULT now(),
  decided_at     timestamptz NULL,
  executed_at    timestamptz NULL,
  reason         text NULL
);

CREATE INDEX IF NOT EXISTS idx_approvals_status_requested_at ON approvals(status, requested_at DESC);
CREATE INDEX IF NOT EXISTS idx_approvals_requester ON approvals(requester_type, requester_id, requested_at DESC);
CREATE INDEX IF NOT EXISTS idx_approvals_approver ON approvals(approver_id, decided_at DESC);

CREATE TABLE IF NOT EXISTS approval_targets (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  approval_id uuid NOT NULL REFERENCES approvals(id) ON DELETE CASCADE,
  employee_id varchar(50) NULL REFERENCES employees(employee_id),
  wallet_id   uuid NULL REFERENCES wallets(id),
  amount      bigint NOT NULL,
  note        text NULL
);

CREATE INDEX IF NOT EXISTS idx_approval_targets_approval_id ON approval_targets(approval_id);
CREATE INDEX IF NOT EXISTS idx_approval_targets_employee_id ON approval_targets(employee_id);

CREATE TABLE IF NOT EXISTS admin_transactions (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  approval_id uuid NOT NULL REFERENCES approvals(id),
  tx_type     varchar(30) NOT NULL, -- mint/burn/transfer
  amount      bigint NULL,
  coin_type   varchar(50) NULL REFERENCES coin_types(coin_type),
  tx_hash     varchar(255) NULL,
  status      varchar(20) NOT NULL DEFAULT 'pending', -- pending/success/failed
  executed_by uuid NULL REFERENCES admin_users(id),
  executed_at timestamptz NULL,
  response    jsonb NULL,
  created_at  timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_admin_tx_approval ON admin_transactions(approval_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_admin_tx_status ON admin_transactions(status, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_admin_tx_hash ON admin_transactions(tx_hash);

-- 관리자 관점 원장(선택): 지갑별 입출금/조정 내역(조회 최적화)
CREATE TABLE IF NOT EXISTS wallet_transactions (
  id                  uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  wallet_id            uuid NOT NULL REFERENCES wallets(id),
  type                 varchar(30) NOT NULL,      -- mint/burn/transfer (adjust는 확장값으로만)
  amount               bigint NOT NULL,           -- +입금 / -출금
  coin_type             varchar(50) NOT NULL REFERENCES coin_types(coin_type),
  counterparty         varchar(255) NULL,
  related_approval_id  uuid NULL REFERENCES approvals(id),
  related_tx_id        varchar(255) NULL,
  operator_id          uuid NULL REFERENCES admin_users(id),
  memo                 text NULL,
  created_at           timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_wallet_tx_wallet_time ON wallet_transactions(wallet_id, created_at DESC, id DESC);
CREATE INDEX IF NOT EXISTS idx_wallet_tx_related_approval ON wallet_transactions(related_approval_id);
```

### 4.5 대시보드 집계(성능)

```sql
CREATE TABLE IF NOT EXISTS stats_daily (
  date           date PRIMARY KEY,
  total_supply   bigint NOT NULL,
  minted_today   bigint NOT NULL DEFAULT 0,
  burned_today   bigint NOT NULL DEFAULT 0,
  active_wallets integer NOT NULL DEFAULT 0,
  created_at     timestamptz NOT NULL DEFAULT now()
);

-- 총 발행량 스냅샷(선택)
CREATE TABLE IF NOT EXISTS supply_summary_history (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  snapshot_at timestamptz NOT NULL DEFAULT now(),
  total_supply bigint NOT NULL,
  metadata    jsonb NULL
);

-- 코인별 상세 스냅샷(선택)
CREATE TABLE IF NOT EXISTS supply_snapshots (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  snapshot_id uuid NOT NULL REFERENCES supply_summary_history(id) ON DELETE CASCADE,
  coin_type   varchar(50) NOT NULL REFERENCES coin_types(coin_type),
  db_total    bigint NOT NULL,
  chain_total bigint NOT NULL,
  matched     boolean NOT NULL DEFAULT false,
  note        text NULL
);

CREATE INDEX IF NOT EXISTS idx_supply_snapshots_snapshot ON supply_snapshots(snapshot_id);
CREATE INDEX IF NOT EXISTS idx_supply_snapshots_coin ON supply_snapshots(coin_type);
```

### 4.6 월별 지급(계획/대상자)

```sql
CREATE TABLE IF NOT EXISTS monthly_plans (
  id           uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  year         integer NOT NULL,
  month        integer NOT NULL, -- 1..12
  coin_type    varchar(50) NOT NULL DEFAULT 'welfare' REFERENCES coin_types(coin_type),
  status       varchar(20) NOT NULL DEFAULT 'draft', -- draft/confirmed
  confirmed_at timestamptz NULL,
  confirmed_by uuid NULL REFERENCES admin_users(id),
  created_at   timestamptz NOT NULL DEFAULT now(),
  updated_at   timestamptz NULL,
  UNIQUE(year, month, coin_type)
);

CREATE INDEX IF NOT EXISTS idx_monthly_plans_ym_status ON monthly_plans(year, month, status);

CREATE TABLE IF NOT EXISTS monthly_payees (
  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  year        integer NOT NULL,
  month       integer NOT NULL, -- 1..12
  employee_id varchar(50) NOT NULL REFERENCES employees(employee_id),
  name        varchar(200) NOT NULL, -- 스냅샷/성능 목적
  coin_type   varchar(50) NOT NULL REFERENCES coin_types(coin_type),
  amount      bigint NOT NULL,
  reason      text NULL,
  status      varchar(20) NOT NULL DEFAULT 'scheduled', -- scheduled/paid/cancelled
  scheduled_at timestamptz NULL,
  paid_at     timestamptz NULL,
  created_by  uuid NULL REFERENCES admin_users(id),
  created_at  timestamptz NOT NULL DEFAULT now(),
  UNIQUE(year, month, employee_id, coin_type)
);

CREATE INDEX IF NOT EXISTS idx_monthly_payees_ym_employee ON monthly_payees(year, month, employee_id);
CREATE INDEX IF NOT EXISTS idx_monthly_payees_ym_status ON monthly_payees(year, month, status);
```

---

## 5. 재무회계결산(물리) — 신규 테이블 제안

UI 요구사항은 “탭 A 재무회계분개(발행/소각 승인내역 기반) / 탭 B 결산보고서(요약 + 준비금·발행부채 포함)”이며,  
현 API 문서에는 **“백엔드 확정 필요”**로 남아 있다.  
따라서 본 절에서는 **Admin DB에 저장형 모델(추천)**과 **조회형 모델(Projection 기반)** 2가지 옵션을 제안한다.

### 5.1 옵션 A(추천): 결산 산출물 저장형(보고/감사 재현성↑)

- 결산 기간(월/분기) 별로 “산출물 스냅샷”을 저장하여, 이후 재조회/감사 시 동일 결과를 재현 가능
- 데이터 원천: approvals/admin_transactions/wallet_transactions + (필요 시) SC/Projection

#### 5.1.1 financial_closing_runs (결산 실행/버전)

```sql
CREATE TABLE IF NOT EXISTS financial_closing_runs (
  id           uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  period_type  varchar(10) NOT NULL, -- month/quarter/half/year
  period_from  date NOT NULL,
  period_to    date NOT NULL,
  status       varchar(20) NOT NULL DEFAULT 'generated', -- generated/closed (마감 도입 시)
  generated_by uuid NULL REFERENCES admin_users(id),
  generated_at timestamptz NOT NULL DEFAULT now(),
  note         text NULL,
  UNIQUE(period_type, period_from, period_to)
);

CREATE INDEX IF NOT EXISTS idx_fin_closing_runs_period ON financial_closing_runs(period_from, period_to);
```

#### 5.1.2 financial_journal_entries (탭 A: 재무회계분개)

```sql
CREATE TABLE IF NOT EXISTS financial_journal_entries (
  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  closing_run_id  uuid NOT NULL REFERENCES financial_closing_runs(id) ON DELETE CASCADE,
  entry_date      date NOT NULL,            -- 분개 일자(기준일)
  event_type      varchar(30) NOT NULL,     -- (MVP) mint/burn, (확장) transfer/conversion/settlement 등
  coin_type       varchar(50) NOT NULL REFERENCES coin_types(coin_type),
  debit_account   varchar(100) NOT NULL,
  credit_account  varchar(100) NOT NULL,
  amount          bigint NOT NULL,
  ref_approval_id uuid NULL REFERENCES approvals(id),
  ref_admin_tx_id uuid NULL REFERENCES admin_transactions(id),
  ref_tx_hash     varchar(255) NULL,
  status          varchar(20) NOT NULL DEFAULT 'generated', -- generated/confirmed (마감 도입 시)
  meta            jsonb NULL,               -- 규칙/근거/추가정보
  created_at      timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_fin_journal_run_date ON financial_journal_entries(closing_run_id, entry_date, id);
CREATE INDEX IF NOT EXISTS idx_fin_journal_ref ON financial_journal_entries(ref_approval_id, ref_admin_tx_id);
```

#### 5.1.3 financial_reports (탭 B: 결산보고서 요약)

```sql
CREATE TABLE IF NOT EXISTS financial_reports (
  id             uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  closing_run_id uuid NOT NULL REFERENCES financial_closing_runs(id) ON DELETE CASCADE,
  coin_type      varchar(50) NOT NULL REFERENCES coin_types(coin_type),
  minted_total   bigint NOT NULL DEFAULT 0,
  burned_total   bigint NOT NULL DEFAULT 0,
  transfer_total bigint NOT NULL DEFAULT 0,
  ending_balance bigint NOT NULL DEFAULT 0,
  account_totals jsonb NULL, -- 계정별 합계(요약): { "1110": 123, "2100": 456 } 형태
  created_at     timestamptz NOT NULL DEFAULT now(),
  UNIQUE(closing_run_id, coin_type)
);
```

#### 5.1.4 reserve_liability_snapshots (탭 B: 결산보고서 - 준비금/발행부채)

```sql
CREATE TABLE IF NOT EXISTS reserve_liability_snapshots (
  id             uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  closing_run_id uuid NOT NULL REFERENCES financial_closing_runs(id) ON DELETE CASCADE,
  coin_type      varchar(50) NOT NULL REFERENCES coin_types(coin_type),
  reserve_account varchar(100) NOT NULL,
  reserve_balance bigint NOT NULL DEFAULT 0,
  liability_account varchar(100) NOT NULL,
  liability_balance bigint NOT NULL DEFAULT 0,
  matched       boolean NOT NULL DEFAULT true, -- 자산/부채 정합성(정책에 따라)
  note          text NULL,
  created_at    timestamptz NOT NULL DEFAULT now(),
  UNIQUE(closing_run_id, coin_type, reserve_account, liability_account)
);

CREATE INDEX IF NOT EXISTS idx_reserve_snap_run_coin ON reserve_liability_snapshots(closing_run_id, coin_type);
```

> “자동 분개 규칙(매핑)” 자체는 재무 정책이며 별도 정의가 필요하므로,  
> `financial_journal_entries.meta`에 “적용 규칙 버전/근거”를 기록해 감사 재현성을 확보한다.

### 5.2 옵션 B: 조회형(Projection 기반, 저장 최소화)

- 결산 조회 시점에 필요한 집계를 **Projection DB**에서 즉시 계산하여 반환
- 장점: 저장량/ETL 단순화
- 단점: 감사 재현성(과거 시점 동일 결과 보장)이 낮아질 수 있음  
  → 이 경우에도 `financial_closing_runs`만 저장해 “조회 시각/기준 블록” 정도는 남기는 방식을 권장

---

## 6. 트랜잭션/멱등/운영 규칙(물리)

### 6.1 승인 확정(Confirm) 트랜잭션 경계

논리 설계서의 권장 순서를 물리 트랜잭션으로 고정한다.

1) `approvals.status = approved` 갱신  
2) `admin_transactions(status=pending)` 생성  
3) (필요 시) `wallet_transactions` 적재  
4) `audit_logs` 기록  

- 1~4는 **DB 트랜잭션(원자성)**으로 처리
- DB 커밋 이후 SC Service 호출(외부 IO)은 다음 중 하나로 수행
  - (권장) **Outbox 패턴**: `outbox` 테이블 기록 → 비동기 워커가 SC 호출
  - (단순) 동기 호출: 실패 시 `admin_transactions.status=failed`로 업데이트

### 6.2 멱등 키/중복 방지

- Admin API → SC Service: `X-Request-Id`를 멱등 키로 사용(참조 패턴)  
- `admin_transactions`에 `request_id` 컬럼을 추가하는 것을 권장(실무 운영 편의)
  - `UNIQUE(request_id)` 또는 `(approval_id, request_id)` 유니크로 중복 실행 방지

### 6.3 페이징/정렬(대량 조회)

- 리스트 API(approvals, transactions, employees 등)는 기본적으로 offset paging을 사용하되
- 거래 이력/원장성 데이터는 **커서 기반 페이지네이션** 권장(참조 패턴)  
  - cursor = base64(`created_at|id`) 또는(`occurred_at|tx_id`)

### 6.4 파티셔닝(선택)

- `wallet_transactions`, `financial_journal_entries`는 월 단위 range partitioning을 검토  
  (조회/다운로드가 기간 기반이며 데이터 증가가 빠를 수 있음)

---

## 7. 성능/운영(물리)

### 7.1 캐시/집계

- 대시보드(supply/daily)는 짧은 TTL 캐시 가능(예: 10~30초)
- 공급량/정합성은 `supply_summary_history` + `supply_snapshots` 기반 스냅샷 활용 가능

### 7.2 모니터링

- Admin API: latency, error rate, DB pool, 4xx/5xx
- SC 연동: 호출 성공률/지연, 재시도율, 멱등키 충돌
- (브로커 사용 시) consumer lag, DLQ, replay 성공률

### 7.3 백업/보존

- Admin DB: PITR + 일별 백업
- 감사/결산 산출물은 별도 보존 정책(예: 5년) 적용 가능

---

## 8. 소스/문서 구조(권장)

참조 물리설계서의 구조를 Admin Web 프로젝트에 맞춰 적용한다.

```
docs/
  conceptual/   # 개념설계서
  logical/      # 논리설계서
  physical/     # 물리설계서(본 문서)
  api/          # API 계약(SSOT, @codegen)
  model/        # 데이터 모델(의미/enum)
```

---

## 9. 미확정(TBD) / 결정을 위한 체크리스트

- [ ] **결산(7번 화면)** API 계약 확정(탭별 조회/다운로드 포맷, 기준 기간)  
- [ ] SC Service 호출 방식 결정: 동기 vs outbox 기반 비동기  
- [ ] Projection DB 필요 범위 결정(거래 이력/잔액/집계 중 어디까지 Admin DB로 충분한지)  
- [ ] 개인정보 컬럼 암호화/마스킹 정책(감사/권한과 연계)  
- [ ] 대량 업로드(코인지급 bulk) API/스키마(업로드 이력 테이블 필요 여부)

